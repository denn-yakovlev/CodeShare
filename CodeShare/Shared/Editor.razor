@inject IJSRuntime _jsRuntime;
@inject ILogger<Editor> _logger;
@inject NavigationManager _navManager;
@using CodeShare.Model.Entities
@using CodeShare.Utils
@using CodeShare.Utils.Logoot
@using Task = System.Threading.Tasks.Task
@implements IAsyncDisposable
@*<div id="editor" style="width: 800px; height: 600px">*@
    <BlazorMonaco.MonacoEditor Id="sample-code-editor-123"
                               @ref="_underlyingEditor"
                               ConstructionOptions="GetConstructionOptions"
                               OnDidChangeModelContent="HandleTextChanges"
                               >
    </BlazorMonaco.MonacoEditor>
@*</div>*@
<MatButton Label="@_label" Raised="true" Style="margin: 10px 10px 10px 0px" @onclick="Toggle" @ref="_button"></MatButton>
@*<InputTextArea @ref="@TextArea">some text</InputTextArea>*@

@code {

    [Parameter]
    public string SessionId { get; set; } = string.Empty;

    [Parameter]
    public CollaborativeEditor LogootEditor { get; set; }

    private bool _isSaved = false;
    private string _label = "Save";

    private MatButton _button;
    private MonacoEditor _underlyingEditor;

    private HubConnection? _connection;
    private IDisposable? _onDeletion;
    private IDisposable? _onInsertion;
    private IDisposable? _onRangeDeletion;
    private IDisposable? _onRangeInsertion;

    private int _site;
    private int _clock = 0;

    private StandaloneEditorConstructionOptions GetConstructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            Language = LogootEditor.SolutionLanguage.Name,
            GlyphMargin = true,
            Value = LogootEditor.Solution.SourceCode
        };
    }

    private void HandleTextChanges(ModelContentChangedEvent e)
    {
        var changesAreNotFromUser = e.IsFlush;
        if (changesAreNotFromUser)
            return;
        foreach (var change in e.Changes)
        {
            var isDeletion = change.RangeLength > 0;
            var isInsertion = change.Text.Length > 0;
            var isDeletionOfOneChar = change.RangeLength == 1;
            var isInsertionOfOneChar = change.Text.Length == 1;

            if (isDeletion)
            {
                if (isDeletionOfOneChar)
                {
                    var atomToDelete = LogootEditor.GetAtomByOffset(change.RangeOffset);
                    LogootEditor.Remove(atomToDelete);
                    _connection.SendAsync("BroadcastDeletionAsync", SessionId, atomToDelete);
                }
                else
                {
                    var atomsToDelete = LogootEditor.GetAtomsArray(change.RangeOffset, change.RangeLength);
                    LogootEditor.RemoveRange(atomsToDelete);
                    _connection.SendAsync("BroadcastRangeDeletionAsync", SessionId, atomsToDelete);
                }
            }
            if (isInsertion)
            {
                var prevAtom = LogootEditor.GetAtomByOffset(change.RangeOffset - 1);
                var nextAtom = LogootEditor.GetAtomByOffset(change.RangeOffset);
                if (isInsertionOfOneChar)
                {
                    var atomToInsert = new LogootAtom(
                        PositionId.Generate((prevAtom.Id, nextAtom.Id), 1, _site, _clock).Single(),
                        change.Text[0]
                        );
                    LogootEditor.Insert(atomToInsert);
                    _connection.SendAsync("BroadcastInsertionAsync", SessionId, atomToInsert);
                }
                else
                {
                    var atomsToInsert = PositionId.Generate(
                        (prevAtom.Id, nextAtom.Id), change.Text.Length, _site, _clock
                        )
                        .Zip(change.Text, (pos, @char) => new LogootAtom(pos, @char));
                    LogootEditor.InsertRange(atomsToInsert);
                    _connection.SendAsync("BroadcastRangeInsertionAsync", SessionId, atomsToInsert);
                }

            }
        }
    }

    void Toggle()
    {
        _label = _isSaved ? "Saved!" : "Save";
        _isSaved = !_isSaved;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _logger.LogDebug($"OnAfterRenderAsync called, firstRender={firstRender}");
        if (firstRender)
        {
            _connection = new HubConnectionBuilder()
                .WithUrl(_navManager.BaseUri + $"editor/{SessionId}")
                //.WithAutomaticReconnect()
                .Build();
            _site = HashCode.Combine(_connection?.ConnectionId ?? string.Empty);
            _connection.Reconnecting += LogReconnecting;
            _connection.Reconnected += LogReconnected;
            _onInsertion = _connection.On<LogootAtom>("Insert", atom =>
            {
                _logger.LogDebug("Client's insert called");
                LogootEditor.Insert(atom);
                UpdateUnderlyingEditor();
            });
            _onDeletion = _connection.On<LogootAtom>("Delete", atom =>
            {
                _logger.LogDebug("Client's delete called");
                LogootEditor.Remove(atom);
                UpdateUnderlyingEditor();
            });
            _onRangeInsertion = _connection.On<IEnumerable<LogootAtom>>("InsertRange", atoms =>
            {
                _logger.LogDebug("Client's insertRange called");
                LogootEditor.InsertRange(atoms);
                UpdateUnderlyingEditor();
            });
            _onRangeDeletion = _connection.On<IEnumerable<LogootAtom>>("DeleteRange", atoms =>
            {
                _logger.LogDebug("Client's deleteRange called");
                LogootEditor.RemoveRange(atoms);
                UpdateUnderlyingEditor();
            });
            await _connection.StartAsync();
            //await _underlyingEditor.SetValue(LogootEditor.Solution.SourceCode);
        }
        await base.OnAfterRenderAsync(firstRender);
        _logger.LogDebug($"OnAfterRenderAsync ended, firstRender={firstRender}");
    }

    private Task LogReconnected(string str)
    {
        return Task.Run(() => _logger.LogInformation($"Reconnected: {str}"));
    }

    private Task LogReconnecting(Exception exc)
    {
        return Task.Run(() => _logger.LogInformation($"Reconnecting, exception: {exc}"));
    }

    private void UpdateUnderlyingEditor()
    {
        _underlyingEditor.SetValue(LogootEditor.Solution.SourceCode);
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        await(_connection?.StopAsync() ?? Task.CompletedTask);
        _connection.Reconnected -= LogReconnected;
        _connection.Reconnecting -= LogReconnecting;
        _onInsertion?.Dispose();
        _onDeletion?.Dispose();
        _onRangeInsertion?.Dispose();
        _onRangeDeletion?.Dispose();
        await (_connection?.DisposeAsync() ?? new ValueTask());
    }
}