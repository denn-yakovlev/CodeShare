@page "/session/{SessionId}"
@implements IAsyncDisposable
@inject IJSRuntime _jsRuntime;
@inject ILogger<Index> _logger;
@inject IHttpContextAccessor _httpCtxAccessor;
@inject CodeShare.Services.SessionsManager.ISessionsManager _sessionsMgr;

@using ISessionState = CodeShare.Model.Entities.ISessionState;
@using Session = CodeShare.Model.Entities.Session;
@using User = CodeShare.Model.Entities.User;
@using Task = System.Threading.Tasks.Task

<div class="sidebar">
    <MatList Style="padding: 0px">
        <MatListGroup>
            <MatListGroupSubHeader Style="color: white; font-weight: bold; margin:18px">
                Collaborators
            </MatListGroupSubHeader>
            <MatListDivider Style="border-color: white"></MatListDivider>
            <div style="max-height: 80vh; overflow: auto">
                @foreach (var collaborator in CurrentSession.Collaborators)
                {
                    <MatListItem Style="color: white;">@collaborator.Name</MatListItem>
                }
            </div>
        </MatListGroup>
    </MatList>
</div>
<div style="margin:1.5rem">
    <h1>@CurrentSession.CurrentTask?.Name</h1>
    @CurrentSession.CurrentTask?.Description
    <Editor @ref="Editor" SessionId="@SessionId" CurrentSession="@CurrentSession"></Editor>
</div>

@code {

    [Parameter]
    public string SessionId { get; set; } = string.Empty;

    private ISessionState CurrentSession { get; set; } = Session.Empty;

    private User _currentUser = User.CreateAnonymous();

    private Editor? Editor { get; set; }

    private DotNetObjectReference<Index>? objRef;

    private async Task UpdateComponent(ISessionState sessionState) =>
        await InvokeAsync(() =>
        {
            _logger.LogInformation($"UpdateComponent called, session {sessionState.Id}");
            StateHasChanged();
        });

    protected override void OnInitialized()
    {
        _logger.LogDebug("OnInitialized called");
        base.OnInitialized();
        _logger.LogDebug("OnInitialized ended");
    }

    protected override async Task OnParametersSetAsync()
    {
        _logger.LogDebug("OnParametersSetAsync called");
        var userName = _httpCtxAccessor.HttpContext.User.Identity.Name;
        if (userName != null)
            _currentUser = new User(userName);
        await _sessionsMgr.ConnectToSessionAsync(_currentUser, SessionId);
        CurrentSession = _sessionsMgr.GetSessionById(SessionId);
        CurrentSession.Connected += UpdateComponent;
        CurrentSession.Disconnected += UpdateComponent;
        await base.OnParametersSetAsync();
        _logger.LogDebug("OnParametersSetAsync ended");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _logger.LogDebug($"OnAfterRenderAsync called, firstRender={firstRender}");
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            await _jsRuntime.InvokeVoidAsync("disposeComponentOnTabClosed", objRef);
        }
        await base.OnInitializedAsync();
        _logger.LogDebug($"OnAfterRenderAsync ended, firstRender={firstRender}");
    }

    [JSInvokable]
    public async ValueTask DisposeAsync()
    {
        _logger.LogDebug($"Disposing {nameof(Index)}");
        await _sessionsMgr.DisconnectFromSessionAsync(_currentUser, SessionId);
        CurrentSession.Connected -= UpdateComponent;
        CurrentSession.Disconnected -= UpdateComponent;
        objRef?.Dispose();
        await (Editor?.DisposeAsync() ?? new ValueTask());
    }
}